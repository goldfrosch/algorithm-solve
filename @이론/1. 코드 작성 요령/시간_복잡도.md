## 개요

알고리즘 문제를 풀기 이전에 알고리즘 문제를 풀 때 고려하면 좋은 사항들에 대해 알아보자

## 시간 복잡도

### 시간 제한이란?

컴퓨터는 1초에 약 3~5억개 정도의 연산을 처리할 수 있다.
다만 연산이 선언, 비트 연산, AND, OR, 비교, 덧셈 등의 단순 연산이 아닌 나눗셈, 곱셈, 대입, 함수 호출 등 의 연산일 경우에 대해 차이가 날 수는 있어 대략적인 값임을 알아야한다.

```
 #include <iostream>
 using namespace std;

 int main() {
    int a,b;
    cin >> a >> b;
    cout << a + b;
 }
```

해당 알고리즘 문제의 시간 제한이 1초라고 가정했을 때

위의 코드는 a,b의 값을 각각 받는 작업 2번, a+b의 값을 출력하는 작업을 진행해 대략 3-4번정도의 작업을 진행하고 종료하게 된다. (0.000001초도 안걸림)
(1초 내에 모든 작업이 수행되고 종료되어 통과할 수 있음.)

알고리즘 문제의 시간 제한은 즉 그 시간 안에 (1초 (3-5억번))안에 모든 작업을 진행하고 종료할 수 있어야 한다를 말해준다.

### 시간 복잡도 연산 방법

```
int func1(int arr[], int n) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] % 5 == 0) cnt++;
    }
    return cnt;
}
```

위의 코드를 예시로 들 때 시간 복잡도를 계산해 본다면...

- 2번째 줄 cnt = 0 할당 시 1번
- 3번째 줄 i = 0 할당 시 1번
- 3번째 줄 반복문 n번만큼 발생
  - i가 n 보다 작은 수일 때 i에 +1만큼 추가 하니 2번
  - arr[i] % 5가 0인지 비교하고 일치할 때 cnt값 증가 2번 (복잡도 계산은 참고로 최대 횟수를 기반으로 진행함)
- cnt 반환 1번

결론: 1 + 1 + n \* (2 + 2 + 1) + 1 => 5n + 3번

이렇게 코드를 하나하나 까면서 시간 복잡도를 계산하기에는 너무 어려움이 있으니 문제를 보면서 시간 복잡도를 계산하는 것도 방법이다.

```
대회장에 N명의 사람들이 일렬로 서있다. 거기서 당신은 이름이 '가나다'인 사람을 찾기 위해 사람들에게 이름을 물어본다.
이름을 물어보고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?
```

최소 1초 최대 N초가 소요된다.

여기서 이름이 가나다 순으로 정렬되었다라고 가정하는 조건이 하나 추가된다면.
중간씩 쪼개서 계산하는 알고리즘(이진 탐색)을 활용해 logN만큼 걸리게 수정이 가능해진다.

두개가 다 제한시간이 1초라고 가정하고 N이 최대 60억이라고 가정한다면

전자: N \* 60억 => 60억 계산 > 1초
후자: Log(60억) => 약 29 계산 < 1초

이런식으로 계산해 제한 시간을 넘기지 않는 것이 시간 복잡도의 목표이다.

### 시간 복잡도 정의

시간 복잡도: 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관 관계

빅오 표기법: 주어진 식을 값이 가장 큰 대표항만 남겨 나타내는 방법

- O(N): **5N** + 3, **2N** + 10LogN // 각각 5N이 가장 크고 2N이 가장 큰 값이라 O(N)이 된다.
- O(N^2): **N^2** + 2N + 4, **6N^2** + 20N + 10LogN

### 시간 복잡도 계산 식

시간 복잡도의 크기:

O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)

#### 1초 중 허용되는 시간 복잡도

1초 동안 허용되는 시간복잡도의 N의 수

```
N <= 11 / O(N!) = 피보나치
N <= 25 / O(2^N) = 재귀함수
N <= 100 / O(N^4)
N <= 500 / O(N^3) // 3중 for문, 행렬간 곱셈
N <= 3000 / O(N^2LogN)
N <= 5000 / O(N^2) // 2중 for문, 삽입, 거품, 선택 정렬, 면적 구하기
N <= 1,000,000 / O(NLogN)
N <= 10,000,000 / O(N) = 1중 for문
그 외 = O(LogN) = 이진 탐색(Binary Search), 퀵, 병합, 힙 정렬, O(1) // 단순 입출력
```

시간 제한 1초에 N이 5,000,000 이라면 O(N), O(LogN), O(1)으로 해결해야 한다는 소리다.
