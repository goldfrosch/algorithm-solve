# 재귀

## 재귀란?

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘으로 특정 조건이 만족할 때 까지 그 함수를 호출해야 하는 경우에 자주 사용된다.

ex.

```
// int n 초기값부터 0이 될 때 까지 해당 함수를 반복함
void func1(int n) {
    if (n == 0) return;
    func1(n - 1);
}

int totalSum(int n, int sum) {
    if (n == 0) return sum;
    return totalSum(n - 1, sum + n);
}
```

## 귀납적인 방식

이전에 알고리즘 문제를 풀 때는 이전에 괄호 쌍 분석을 위해 스택을 활용하면서 스택이 비어있는지 스택의 top과 짝이 맞는지를 비교하면서 각각의 상황에 따라 해결하는 방식이였다면 재귀는 조금 다른 방식으로 생각할 필요가 있다.

도미노를 예시로 들게되면 이전에 했던 생각 방식(절차 지향)으로 생각하게 된다면 1번째 도미노가 쓰러지면 2번째 도미노가 쓰러지고, 그 2번째 도미노가 쓰러지면 3번째 도미노가 쓰러지는 즉 하나 하나 쓰러진다는 순서를 기반으로 생각하게 되는데,

재귀는 수학적 귀납법을 이용해 1번 도미노가 쓰러지면, K번 도미노가 쓰러지면 K+1번째 도미노도 쓰러진다가 되어 모든 도미노가 쓰러진다는 결론에 도달 되어야 한다.

이전에는 하나하나 다 쓰러지는 것을 보면서 결론을 추론했다면 이제는 하나의 예시를 보고도 바로 모든 도미노가 쓰러진다는 결론에 도달하는 방식으로 생각해야한다.

## 재귀의 조건

올바른 재귀 함수의 특징은 반드시 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 한다. 이것을 base condition 혹은 base case라고 부른ㄷ나.

(사실 특정 케이스에 자기 자신을 호출하지 않고 종료시키지 않으면 무한 반복이 일어나니...)

## 재귀의 특징

- 함수의 인자로 어떤 것을 받고 어디까지 계산하고 자기 자신에게 넘겨줄 지 명확하게 지정해야함.
- 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음.
  - 재귀는 잘 활용하면 코드가 간결해지나, 함수 호출은 비용이 큰 연산이기 때문에 메모리와 시간에서 손해를 보게 된다. (굳이 외부에 함수를 선언하고 호출하는게 안 좋을 수도 있음)
  - 굳이 재귀를 안써도 될 것 같으면 쓰지말자.
- 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음.

  - 재귀 안에서 자기 자신을 여러번 호출하게 되는 것이 생각보다 더 비효율적으로 될 수 있다.

  ```
    int fibo(int n) {
        if(n <= 1) return 1;
        return fibo(n - 1) + fibo(n - 2);
    }
  ```

  - 위 함수를 예시로 든다면 N번째 피보나치 수열을 반환하는 함수인데 base case는 n이 1 이하이고 그 외의 입력들은 전부 base case에 수렴할 것이다. 일반적으로 생각해본다면 피보나치 수열의 합울 계산하는 것은 1,1,2,3,5,8 - - - 해서 N번의 덧셈으로 끝낼 수 있으나 위 코드의 시간 복잡도는 O(1.618^n)이다. 즉 n = 100정도만 되어도 일반 컴퓨터로 20000년 넘게 걸릴 수 있는 계산이 된다.

  - 이 이슈가 발생하는 이유는 fibo에서 n-1, n-2가 확장되면서 계산되는데 n이 5라고 가정하면 저 확장 방식에서 fibo(4), fibo(3), fibo(3), fibo(2) ... 이런식으로 호출되기 때문에 불필요한 계산이 섞여 들어간다. 지금보면 불필요한 계산이 fibo(3)만 보이지만 저기서도 재귀가 되는 것을 생각하게 되면 더 많은 동일하지만 불필요한 작업이 섞여 들어가게 된다.

- 재귀는 호출될 때 마다 스택 메모리 영역에 계속 누적됨.
  - 일부 채점 사이트에서는 스텍 메모리 제한을 메모리 제한과 별도로 잡는 경우도 있는데 재귀를 쓸 경우 너무 많은 재귀를 호출하는 것을 방지하기 위해 설정하기도 함.
