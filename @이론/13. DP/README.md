# DP (다이나믹 프로그래밍)

DP는 큰 개념 없이 다양한 문제를 풀어보면서 익히면 되는 개념이다

## DP란?

여러개의 하위 문제를 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘으로 문제를 해결하기 위한 점화식을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가 답을 알아내는 알고리즘을 말한다.

### 예시

가장 대표적인 예시로는 피보나치 수열을 예시로 들게된다. 피보나치 수열을 순수하게 계산하려면 N번째 항을 재귀적으로 구해야하기 때문에 시간 복잡도는 O(1.618^N)이라는 어마무시한 숫자가 된다. 피보나치가 이렇게 오래걸리는 이유 중 하나는 중복된 연산이 포함되는데 이전 값들을 더하고 더해서 구해지는게 피보나치인 만큼 이 문제를 DP로 풀게되면 시간복잡도가 많이 줄어들게 된다.

```
// AS-IS
int fibo(int n) {
    if(n <= 1) return 1;
    return fibo(n - 1) + fibo(n - 2);
}

// TO-BE
int fibo(int n) {
    int f[20];
    f[0] = f[1] = 1;

    for (int i = 2; i <= n; i++)
        f[i] = f[i - 1] + f[i - 2];

    return f[n];
}
```

위처럼 DP라는 개념을 활용해 어느정도의 값을 미리 넣어두고 점화식 기반으로 값을 계산하게 되면 O(1.618^N)에서 O(N)으로 시간 복잡도가 많이 줄어드는 기적을 볼 수 있다.

## DP 해결 방법

DP 관점으로 문제를 풀기 위해서는 밑의 3가지 과정을 거치면서 풀어야한다.

1. 테이블 정의하기
2. 점화식 찾기
3. 초기값 정하기

DP는 작정하고 어렵게 내고자하면 매우 어려워질 수 있지만, 코딩테스트에서 나올만한 DP는 점화식만 찾으면 그 뒤부터는 초기 값을 채워넣고 반복문을 돌면서 배열을 채우면 끝이기에 구현이 굉장히 쉬운 알고리즘이다.

### 예제

백준 기준으로 1463번을 해결하게 된다면 (https://www.acmicpc.net/problem/1463)

#### 테이블 정의하기

이것도 감각적으로 익혀야하는 부분이지만 우선은 테이블을 정의하면 D[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값이라는 테이블을 만든다. (D의 배열)

#### 점화식 찾기

예를 들어 X가 12로 값이 들어오는 경우 D[1] ~ D[12]까지 다 계산할 수 없으니 점화식을 찾아야한다.

```
D[12] = ?
3으로 나누는 경우 D[12] = D[4] + 1
2로 나누는 경우 D[12] = D[6] + 1
1을 빼거나 (D[12] = D[11] + 1)

D[12] = min(D[4] + 1, D[6] + 1, D[11] + 1)
```

즉 D[6] + 1, D[4] + 1, D[11] + 1 중 최솟값을 찾으면 되고, D의 6,4,11의 값만 구하면 된다라는 말이 된다.

#### 초기값 정의하기

D[1] = 0

#### 완성하기

이 규칙을 기반으로 하나하나 풀어나가게 되면 되게 간단한 수식이 나오게 된다.
1을 뺀 결과값과 2나 3으로 나눈 결과값들을 각각 비교함으로써 O(N)안에 모든 작업을 수행이 가능한 것이다.

```
int N;
int NL[100001];

int main() {
    std::cin >> N;

    NL[1] = 0;
    for (int i = 2; i <= N; i++) {
        NL[i] = NL[i - 1] + 1;

        if (i % 2 == 0) NL[i] = min(NL[i], NL[i / 2] + 1);
        if (i % 3 == 0) NL[i] = min(NL[i], NL[i / 3] + 1);
    }

    std::cout << NL[N];

    return 0;
}

```
