# 수학

알고리즘에서 수학 문제 자체가 나오는 경우가 드물다. 흔히 전공자들이 배우는 이산수학, 선형 대수학 등이 나오지는 않지만 기본적인 소수, 최대 공약수, 최소 공배수 등 나올법 한 일부 수학 문제에 대해 정리해보자

## 소수

소수 문제에 관련해서는 은근히 문제가 출제되는 경향이 있다.

### 정의

소수는 1과 자기 자신으로만 나누어지는 수, 그렇기에 약수가 2개인 수를 말하기도 한다. (약수가 2개이려면 1과 자기 자신이기에)

소수의 반대인 합성수는 진짜 반대로 1과 자기 자신만으로 나누어지지 않고 약수가 3개 이상인 수를 말한다.

가장 중요한 사실은 1은 소수도 합성수도 아니다. 약수가 1개이기 때문이다.

### 판단 방법

소수를 판단하는 방법의 정의는 다음과 같다.

- 1과 자기 자신으로만 나뉘어진 수
- 약수가 2개인 수
- 2부터 N - 1까지의 수로 나누어지지 않는 수

위의 조건 자체를 충족하는 로직을 짜는 것은 매우 간단하다.

```
bool isPrime(int number) {
    // 1은 소수로 정의되지 않는다. 다만 위 함수가 아닌 조건에서 부터 걸려져올 가능성이 높다.
    if (number == 1) return false;
    for (auto i = 2; i < number - 1; i++) {
        if (number % i == 0) return false;
    }

    return true;
}
```

조건에 맞는 식을 그대로 작성하게 된다면 O(N)만큼의 시간 복잡도로 문제를 해결할 수 있다. 그리고 여러개의 숫자를 정의하게 된다면 O(N^2)만큼 소요되게 될 것이다.

### 소수 계산식

사실 O(N)도 굉장히 짧은 편이지만 정해진 규칙을 찾게된다면 소수는 O(N)이 아닌 O(√n)으로도 통과가 가능하다. (√ = 제곱근)

이 규칙을 찾으려면 약간의 관찰이 필요하다. 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하라는 것을 우선 알아야한다.

18, 25, 21을 예시로 들면 N = 18이면 18에서 가장 작은 약수는 2다. (1은 당연히 제외한다.) 그리고 √18 = 4.xx이고 2는 √18 이하이다.

25, 21에서도 동일한 원리가 적용된다. 25의 가장 작은 약수는 5고 √25 = 5, 21의 가장 작은 약수는 3, √21 = 4.xx다.

위의 정의를 읽어보았을 때 다음과 같은 정의가 이루어진다.

- 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하이다.
- 그렇다면 2부터 √N 까지로 나뉘어지지 않는다면 소수다.

즉 기존에는 N - 1까지 비교한 것을 √N 까지만 비교함으로써 엄청 많은 시간 복잡도를 줄일 수 있는 것이다.

```
bool isPrime(int number) {
    // 1은 소수로 정의되지 않는다. 다만 위 함수가 아닌 조건에서 부터 걸려져올 가능성이 높다.
    if (number == 1) return false;
    // i * i <= number 조건식을 줌으로써 number가 i^2보다 작거나 같은지 즉 제곱근을 확인한다.
    for (auto i = 2; i * i <= number; i++) {
        if (number % i == 0) return false;
    }

    return true;
}
```

### 에라토스테네스의 체

기존에 개선한 로직을 사용하면 소수 하나를 판별하는데 O(√N) 만큼 소모된다. 그리고 N만큼의 수를 판별하게 된다면 다시 O(N)만큼 소요하게 될 것이다.

이전 식을 통해서 소수를 판별하는 경우의 수를 줄였다면 범위 내에서 소수를 판정하는 더 좋은 알고리즘인 에라토스테네스의 체에 대해 알아보자

```
[1,2,3,4,5,6,7,8,9,...25]
```

1부터 N까지 소수의 목록을 구하고 싶다고 하였을 때 N칸 짜리 배열을 만들고 해당 칸이 소수일 경우는 true, 아닐 경우는 false를 가지게하면 된다.

이제 밑의 일련의 과정을 거치면서 문제를 해결해보면 된다.

- 2가 소수임을 확인했다면 2의 배수는 전부 false로 소수가 아니게 된다.
- 3이 소수임을 확인 후 3의 배수를 전부 false로 처리한다.
- 4는 2의 배수라 skip되고 5가 소수임을 확인해 5의 배수는 전부 false로 처리한다.
- 계속 반복한다...

이 작업을 반복해준다면 이전에 소수를 계산하는 알고리즘인 O(√N)에 중간에 검증하는 로직도 O(NlogNlogN)이라는 생전 처음보는 시간 복잡도가 나와 N이 50,000,000이여도 0.5초 이내로 계산이 끝나는 현상이 발생하게 된다

```
bool isPrimeCheck[9999999];

bool isPrime(int max) {
    for (int i = 2; i <= max; i++) {
        if (isPrimeCheck[i]) continue;
        // 초기값을 i * 2가 아닌 i * i로 잡는 이유는 어차피 2의 배수는 처음에 막히게 될꺼고 그 다음 숫자들도 계속 막히기 때문에 첫 시작을 제곱을 기준으로 시작하는 것이다. 추후 j의 값을 이전 값에 i를 더하면서 그 배수를 제외하는 것이다.
        for (int j = i * i; j <= max; j += i) isPrimeCheck[j] = true;
    }
}
```
