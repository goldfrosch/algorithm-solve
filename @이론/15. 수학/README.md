# 수학

알고리즘에서 수학 문제 자체가 나오는 경우가 드물다. 흔히 전공자들이 배우는 이산수학, 선형 대수학 등이 나오지는 않지만 기본적인 소수, 최대 공약수, 최소 공배수 등 나올법 한 일부 수학 문제에 대해 정리해보자

## 소수

소수 문제에 관련해서는 은근히 문제가 출제되는 경향이 있다.

### 정의

소수는 1과 자기 자신으로만 나누어지는 수, 그렇기에 약수가 2개인 수를 말하기도 한다. (약수가 2개이려면 1과 자기 자신이기에)

소수의 반대인 합성수는 진짜 반대로 1과 자기 자신만으로 나누어지지 않고 약수가 3개 이상인 수를 말한다.

가장 중요한 사실은 1은 소수도 합성수도 아니다. 약수가 1개이기 때문이다.

### 판단 방법

소수를 판단하는 방법의 정의는 다음과 같다.

- 1과 자기 자신으로만 나뉘어진 수
- 약수가 2개인 수
- 2부터 N - 1까지의 수로 나누어지지 않는 수

위의 조건 자체를 충족하는 로직을 짜는 것은 매우 간단하다.

```
bool isPrime(int number) {
    // 1은 소수로 정의되지 않는다. 다만 위 함수가 아닌 조건에서 부터 걸려져올 가능성이 높다.
    if (number == 1) return false;
    for (auto i = 2; i < number - 1; i++) {
        if (number % i == 0) return false;
    }

    return true;
}
```

조건에 맞는 식을 그대로 작성하게 된다면 O(N)만큼의 시간 복잡도로 문제를 해결할 수 있다. 그리고 여러개의 숫자를 정의하게 된다면 O(N^2)만큼 소요되게 될 것이다.

### 소수 계산식

사실 O(N)도 굉장히 짧은 편이지만 정해진 규칙을 찾게된다면 소수는 O(N)이 아닌 O(√n)으로도 통과가 가능하다. (√ = 제곱근)

이 규칙을 찾으려면 약간의 관찰이 필요하다. 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하라는 것을 우선 알아야한다.

18, 25, 21을 예시로 들면 N = 18이면 18에서 가장 작은 약수는 2다. (1은 당연히 제외한다.) 그리고 √18 = 4.xx이고 2는 √18 이하이다.

25, 21에서도 동일한 원리가 적용된다. 25의 가장 작은 약수는 5고 √25 = 5, 21의 가장 작은 약수는 3, √21 = 4.xx다.

위의 정의를 읽어보았을 때 다음과 같은 정의가 이루어진다.

- 합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하이다.
- 그렇다면 2부터 √N 까지로 나뉘어지지 않는다면 소수다.

즉 기존에는 N - 1까지 비교한 것을 √N 까지만 비교함으로써 엄청 많은 시간 복잡도를 줄일 수 있는 것이다.

```
bool isPrime(int number) {
    // 1은 소수로 정의되지 않는다. 다만 위 함수가 아닌 조건에서 부터 걸려져올 가능성이 높다.
    if (number == 1) return false;
    // i * i <= number 조건식을 줌으로써 number가 i^2보다 작거나 같은지 즉 제곱근을 확인한다.
    for (auto i = 2; i * i <= number; i++) {
        if (number % i == 0) return false;
    }

    return true;
}
```

### 에라토스테네스의 체

기존에 개선한 로직을 사용하면 소수 하나를 판별하는데 O(√N) 만큼 소모된다. 그리고 N만큼의 수를 판별하게 된다면 다시 O(N)만큼 소요하게 될 것이다.

이전 식을 통해서 소수를 판별하는 경우의 수를 줄였다면 범위 내에서 소수를 판정하는 더 좋은 알고리즘인 에라토스테네스의 체에 대해 알아보자

```
[1,2,3,4,5,6,7,8,9,...25]
```

1부터 N까지 소수의 목록을 구하고 싶다고 하였을 때 N칸 짜리 배열을 만들고 해당 칸이 소수일 경우는 true, 아닐 경우는 false를 가지게하면 된다.

이제 밑의 일련의 과정을 거치면서 문제를 해결해보면 된다.

- 2가 소수임을 확인했다면 2의 배수는 전부 false로 소수가 아니게 된다.
- 3이 소수임을 확인 후 3의 배수를 전부 false로 처리한다.
- 4는 2의 배수라 skip되고 5가 소수임을 확인해 5의 배수는 전부 false로 처리한다.
- 계속 반복한다...

이 작업을 반복해준다면 이전에 소수를 계산하는 알고리즘인 O(√N)에 중간에 검증하는 로직도 O(NlogNlogN)이라는 생전 처음보는 시간 복잡도가 나와 N이 50,000,000이여도 0.5초 이내로 계산이 끝나는 현상이 발생하게 된다

```
bool isPrimeCheck[9999999];

bool isPrime(int max) {
    for (int i = 2; i <= max; i++) {
        if (isPrimeCheck[i]) continue;
        // 초기값을 i * 2가 아닌 i * i로 잡는 이유는 어차피 2의 배수는 처음에 막히게 될꺼고 그 다음 숫자들도 계속 막히기 때문에 첫 시작을 제곱을 기준으로 시작하는 것이다. 추후 j의 값을 이전 값에 i를 더하면서 그 배수를 제외하는 것이다.
        for (int j = i * i; j <= max; j += i) isPrimeCheck[j] = true;
    }
}
```

### 소인수 분해

소인수 분해는 정수를 소수의 곱으로 나타내는 것을 의미하며, 모든 자연수는 소인수 분해하는 방법이 하나만 있다.

#### 예시

1100을 소인수 분해한다고 가정해본다면 작은 숫자 단위부터 나누는 작업을 진행한다. i는 2부터 1씩 늘려나가면서 나눠지는 지 확인한다.

```
N = 1100;
i = 2;

-> 소인수 분해
(소인수 목록: [2])
N = 550;

-> 소인수 분해
(소인수 목록: [2, 2])
N = 275;

-> 소인수 분해
(소인수 목록: [2, 2, 5])
N = 55;

-> 소인수 분해
(소인수 목록: [2, 2, 5, 5])
N = 11;

-> 소인수 분해
(소인수 목록: [2, 2, 5, 5, 11])
N = 1;
```

대신 이 방법이 진짜 정당한 방법인지 의문이 들 수 있다. i가 2에서부터 1씩 증가하며 N을 나눌수 있는 수인지 확인 되어야 하는 것도 있지만, i들이 꼭 소수인지에 대해서도 의문이 생기게 된다.

해당 방법을 통해서 나온 소인수 목록은 무조건 소수임이 보장 된다. 이유는 i는 작은 수부터 증가하고 중간에 합성수(소수가 아닌 수)가 들어가있다고 가정해보자

예를 들어 [2, 4, 5] 이런식으로 들어가 있다라고 가정하게 된다면 4는 2 \* 2 인 수이기 때문에 i가 2인 경우에 진작 나누어져야 하기 때문에 4가 들어가는 것은 말이 되지 않는다.

#### 개선 방안

위의 방안대로 하면 N이 1일 때까지 계산하는 로직이 존재하게 된다. 다만 이 방식은 조금 길게 동작할 수 있다.

소수의 조건 중 `합성수 N에서 1을 제외한 가장 작은 약수는 √N 이하이다.`라는 조건을 기억해본다면 소인수 분해를 할 때 아무리 소수가 큰 수더라도 √N 보다는 작다라는 것이 되기 때문에

N이 1이 될 때까지 검증하기 보다는 i \* i 가 N이 될 때 까지만 검증하게 된다면 훨씬 더 낮은 시간 복잡도를 가지게 될 수 있다.
